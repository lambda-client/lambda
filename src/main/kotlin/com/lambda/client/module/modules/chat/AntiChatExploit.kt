package com.lambda.client.module.modules.chat

import com.lambda.client.module.Category
import com.lambda.client.module.Module
import com.lambda.client.util.text.HarmfulFilters
import com.lambda.event.listener.listener
import net.minecraftforge.client.event.ClientChatReceivedEvent
import java.util.concurrent.ConcurrentHashMap
import java.util.regex.Pattern

object AntiChatExploit : Module(
    name = "AntiChatExploit",
    category = Category.CHAT,
    description = "Removes malicious patterns from the chat",
    showOnArray = false
) {
    private val filterOwn by setting("Filter Own", false)


    private val messageHistory = ConcurrentHashMap<String, Long>()

    init {
        onDisable {
            messageHistory.clear()
        }

        listener<ClientChatReceivedEvent> { event ->
            if (mc.player == null) return@listener

            messageHistory.values.removeIf { System.currentTimeMillis() - it > 600000 }

            val pattern = isHarmful(event.message.unformattedText)

            pattern?.let {event.isCanceled = true }
            }
        }

    private fun isHarmful(message: String): String? {
        return if (!filterOwn && isOwn(message)) {
            null
        } else {
            detectHarmfulMessages(message)
        }
    }

    private fun detectHarmfulMessages(message: String): String? {
        for (harmfulString in HarmfulFilters.harmfulStrings) {
            if (message.contains(harmfulString)) {
                return message
            }
        }
        return null
    }

    private fun isOwn(message: String): Boolean {
        val ownFilter = "^<" + mc.player.name + "> "
        return Pattern.compile(ownFilter, Pattern.CASE_INSENSITIVE).matcher(message).find()
    }
}
